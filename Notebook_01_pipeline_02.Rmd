---
title: "AF2pdbComp"
author: "Neshatul Haque"
date: '2022-09-27'
output:
  pdf_document: default
  html_document: default
fig_width: 6 
fig_height: 3 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Large scale comparision of PDB structures and AF2 structures:
AlphaFold2 (AF2) has shown significant promise in predicting the three-dimensional structures of proteins from their sequences. Often, these predicted structures closely resemble those determined experimentally. However, under specific experimental conditions, alternative conformations, particularly off-state structures, can emerge and be resolved as three-dimensional models. This project aims to investigate the structural states generated by the prediction algorithm and their similarity to known 3D models. Additionally, we seek to understand the underlying factors that might influence any observed preference in the predicted structures.

# Variables to be provided by the users
```{r USER_DEFINED_PATHS}
#data and code dir from git repository
dcd <- "." # PROVIDE THE PATH TO GIT REPO ON YOUR COMPUTER
data <- file.path(dcd, "data") # Dir to save data


## User should provide the path to following applications
PYMOL_PATH <- "/hpc/apps/miniconda3/4.9.2/envs/pymol-2.5.0/bin"
STRIDE_PATH <- "~/Applications/STRIDE/stride"
PDB_to_XYZR <- "~/Applications/3v/vossvolvox/xyzr/pdb_to_xyzr"
CDHIT_PATH <- "/hpc/apps/cd-hit/4.8.1"
FATCAT_EXE <- "/XXX/XXX/Applications/fatcat/FATCAT-dist/FATCATMain/FATCAT"


```

```{r dependencies_and_PATHS, include=FALSE}
source(file.path(dcd, "utils.R"))
# provide the number of cores available
NUM_CORES <- 48

#The CATH data download dir
#CATH_DB_PATH <- "/hpc/refdata/cathdb/v4_3_0"  
CATH_DB_PATH <- file.path(data, "CATHdb/v4_3_0")
if(!dir.exists(CATH_DB_PATH)){
  dir.create(CATH_DB_PATH)
}

CATH_DB_SEQ_PATH <- file.path(data, "CATHdb/v4_3_0_seq")
if(!dir.exists(CATH_DB_SEQ_PATH)){
  dir.create(CATH_DB_SEQ_PATH)
}


CATH_DB_RSA_PATH <- file.path(data, "CATHdb/v4_3_0_rsa")
if(!dir.exists(CATH_DB_RSA_PATH)){
  dir.create(CATH_DB_RSA_PATH)
}

# In RMSD6  calculation we can save CATH domain truncated structures.
# By default it is off
CATH_DB_PATH_TRUNC <- file.path(data, "CATHdb/v4_3_0_trunc")
if(!dir.exists(CATH_DB_PATH_TRUNC)){
  dir.create(CATH_DB_PATH_TRUNC)
}


AF2_DOM_DB_PATH <- file.path(data, "CATHdb/v4_3_0_af2_dom")
if(!dir.exists(AF2_DOM_DB_PATH)){
  dir.create(AF2_DOM_DB_PATH)
}


AF2_DOM_DB_RSA_PATH <- file.path(data, "CATHdb/v4_3_0_af2_dom_rsa")
if(!dir.exists(AF2_DOM_DB_RSA_PATH)){
  dir.create(AF2_DOM_DB_RSA_PATH)
}


AF2_DB_PATH <- file.path(data, "AF2_model")
if(!dir.exists(AF2_DB_PATH)){
  dir.create(AF2_DB_PATH)
}


RCSB_DB_PATH <- file.path(data, "RCSBdb")
if(!dir.exists(RCSB_DB_PATH)){
  dir.create(RCSB_DB_PATH)
}

#Relative Solvent Accessible Surface Area files for each corresponding files 
#in RCSB_DB_PATH. STRIDE provided surface area is converted into relative SA.
RSA_PATH <- file.path(data, "RCSBdb_RSA")
if(!file.exists(RSA_PATH)){
  dir.create(RSA_PATH)
}


#The standard AA surface area data is obtained from naccess
NACCESS_STD_DATA <- file.path(data, "NACCESS_std_AA_SA_data.txt")
```

# The preliminary data obtained by compiling information from CATH db is "CATHUNP2"
```{r DataLoader}
CATHUNP2 <- read.table(file.path(data,"CATHUNP2.tab"), header = T)
str(CATHUNP2)
```


## Download databases before starting the analysis
# Download CATH DB
```{r Download_CATH_domain_str, echo=FALSE}

dom_list <- unique(CATHUNP2$Dom)


pb <- progress::progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                       total = length(dom_list), complete = "=", incomplete = "-", current = ">",
                       clear = FALSE, width = 100)

downloadCATH <- TRUE
if(downloadCATH) {
  responseL <- list()
  for (i in seq_along(dom_list)){
    pb$tick()
    response <- GetCthDomStr(CthLocalDb = file.path(data, "CATHdb") , 
                         Cath_db_version = "v4_3_0", 
                         Cath_domain = dom_list[i], 
                         verbose = T)
    responseL[i] <- paste0(response, collapse = ";")
    #print(unp)
  }
}

```





# Download the AF2 Structure
```{r Download_AF_model echo=FALSE}

unp_list <- unique(CATHUNP2$SP_PRIMARY)


pb <- progress::progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                       total = length(unp_list), complete = "=", incomplete = "-", current = ">",
                       clear = FALSE, width = 100)
downloadAF2 <- TRUE
if(downloadAF2) {
  responseL <- list()
  for (unp in seq_along(unp_list)){
    pb$tick()
    response <- GetAF2str(unpid = unp_list[unp], 
                          af2dbpath=file.path(data, "AF2_model"), 
                          verbose = T)
    responseL[unp] <- paste0(response, collapse = ";")
    Sys.sleep(0.1)
  }
}


# AF2 strs missing in the data/AF2_model
af2strs_missing <- list()
counter <- 0
for (z in seq_along(unp_list)){
  fileSize <- file.size(file.path(data, "AF2_model/", 
                        paste0(unp_list[z], "-F1-model_v3.pdb")))
  if (fileSize < 200){
    counter <- counter+1
    af2strs_missing$SP_PRIMARY[counter] <- unp_list[z]
    af2strs_missing$AF2ID[counter] <- paste0(unp_list[z], "-F1-model_v3.pdb")
  }
}
af2strs_missing <- as.data.frame(af2strs_missing)

```






# Download all the protein 3D model from RCSB present in our CATH domain list
```{r RCSB_download}
#unique PDB ID list
PDB_LIST <- lapply(CATHUNP2$Dom, function(p){strsplit(p, split='')[[1]][1:4] %>% paste0(., collapse = '')}) %>% unlist() %>% unique()

pb <- progress::progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                       total = length(PDB_LIST), complete = "=", incomplete = "-", current = ">",
                       clear = FALSE, width = 100)

downloadRSSB <- TRUE
if(downloadRSSB){
    for(pdb_id in PDB_LIST){
    pb$tick()
    GetRCSBcoordFile(pdbid=pdb_id, FileType="cif", Compress=T, output_path = RCSB_DB_PATH)
    Sys.sleep(0.1)
  }
}


TEMP <- pbmcapply::pbmclapply(PDB_LIST, function(x){
  inFile <- file.path(RCSB_DB_PATH, paste0(x, ".cif.gz"))
  outFile <- file.path(RCSB_DB_PATH, paste0(x, ".pdb"))
  cmnd <- str_interp("${PYMOL_PATH}/pymol -cq ${dcd}/Covert_CIF2PDB.pml ${inFile} ${outFile}")
  system(cmnd, ignore.stdout = T)
}, mc.cores=NUM_CORES)

```





## Domain extraction from AF2 models and cannonical RMSD calculation
```{r echo=FALSE}

source("script01_Extract_AF2_dom.R")
AF2_data <- NULL


#GetAF2Cols(which(CATHUNP2$Dom=="1ft1B00"))
if(!file.exists(file.path(data, "data01_Ext_AF2Dom_RMSD.tab"))){
  
  AF2_data <- NULL 
  #It takes apporximately 40 mins to run. If run in normal loop  it would take ~12 hrs
  system.time(AF2_data <- pbmcapply::pbmclapply(1: length(CATHUNP2[,1]), function(x){
    GetAF2Cols(x, outputdir=data, outputfile="data01_Ext_AF2Dom_RMSD.tab")
  }, mc.cores = NUM_CORES)) # with progress bar
    

}

``` 





## Domain extraction from AF2 models and RMSD6 calculation
```{r echo=FALSE}
source("script02_rmsd6.R")

if(!file.exists(file.path(data, "data01_Ext_AF2Dom_RMSD.tab"))){
  AF2_data <- NULL
# It takes apporximately 40 mins to run. If run in normal loop  it would take ~12 hrs
system.time(AF2_data <- pbmcapply::pbmclapply(1: length(CATHUNP2[,1]), function(x){
  GetAF2Cols(x, outputdir=data, outputfile="data01_Ext_AF2Dom_RMSD.tab")
  }, mc.cores = NUM_CORES)) # with progress bar
}

```




# Domain Solven Accecible surface area
```{r echo=FALSE}

#RUN stride on PDBs
TEMP <- pbmcapply::pbmclapply(PDB_LIST, function(x){
  inFile <- file.path(RCSB_DB_PATH, paste0(x, ".pdb"))
  outFile <- file.path(RSA_PATH, paste0(x, ".rsa"))
  sse <- stride.WF(file.path(inFile), STRIDE_PATH)
  write.table(sse, file = outFile, row.names = F, col.names = T, quote = F, sep = "\t")
}, mc.cores=NUM_CORES)


# Compile rsa file for domains
source(file.path(dcd, "script03_SecStr_ReASA.R"))

if(!file.exists(file.path(data, "data03_SecStr_ReASA.tab"))){
  relasadf <- NULL
  system.time(relasadf <- do.call(rbind, pbmcapply::pbmclapply(1: length(CATHUNP2[,1]), GetRelASACols, mc.cores = 48)))
  
  write.table(relasadf, file = file.path(data, "data03_SecStr_ReASA.tab"), row.names = F,      col.names = T, quote = F, sep = "\t")
}
```



# volume and surface area of the domain
```{r}
#   3v   vossvolvox
source(file.path(dcd, "script04_Vol_Surf.R"))

if(!file.exists(file.path(data, "data04_VolSurf.tab"))){
  volsurf_df <- NULL
  system.time(volsurf_df <- do.call(rbind, pbmcapply::pbmclapply(1: length(CATHUNP2[,1]), v3vol, mc.cores = 48)))
  write.table(volsurf_df, file = file.path(data, "data04_VolSurf.tab"), row.names = F,      col.names = T, quote = F, sep = "\t")
}
```


# Sequence of domains clustered
```{r SEQ_CLUST}

if(!file.exists(file.path(data, "data05_SeqClust.tab"))){
  
  scource(file.path(dcd, "script05_SeqClust.R"))
  
} else{
  str(read.table(file.path(data, "data05_SeqClust.tab"), header = T))
}



```


# Secondary structure gain/loss
```{r}
source(file.path(dcd, "script06_SecStr_loss.R"))


## Secondary str of CATH domain
#RUN stride on PDBs of CATH domain
PDB_LIST <- CATHUNP2$Dom
TEMP <- pbmcapply::pbmclapply(PDB_LIST, function(x){
  inFile <- file.path(CATH_DB_PATH, paste0(x, ".pdb"))
  outFile <- file.path(CATH_DB_RSA_PATH, paste0(x, ".rsa"))
  sse <- stride.WF(file.path(inFile), STRIDE_PATH)
  write.table(sse, file = outFile, row.names = F, col.names = T, quote = F, sep = "\t")
}, mc.cores=NUM_CORES)


## Secondary structure of AF2 domains
#RUN stride on PDBs of AF2 domains
PDB_LIST <- CATHUNP2$Dom %>% paste0(., "_af2")
TEMP <- pbmcapply::pbmclapply(PDB_LIST, function(x){
  inFile <- file.path(AF2_DOM_DB_PATH, paste0(x, ".pdb"))
  outFile <- file.path(AF2_DOM_DB_RSA_PATH, paste0(x, ".rsa"))
  sse <- stride.WF(file.path(inFile), STRIDE_PATH)
  write.table(sse, file = outFile, row.names = F, col.names = T, quote = F, sep = "\t")
}, mc.cores=NUM_CORES)

if(!file.exists(file.path(dcd, "data06_SecStr_loss.tab"))){
  SecStr <- NULL
  system.time(SecStr <- do.call(rbind, pbmcapply::pbmclapply(1:length(CATHUNP2[,1]), getSecStr, mc.cores = NUM_CORES))) 
  write.table(SecStr, file = file.path(data, "data06_SecStr_loss_test.tab"), row.names = F,      col.names = T, quote = F, sep = "\t")
}

```



```{r}
source("/scratch/g/mtzimmermann/NH/AF2_manuscript_codes_data/script07_FATCAT_rmsd.R")


if(!file.exists(file.path(dcd, "data09_FATCAT_RMSD.tab"))){
  fatcat <- NULL
  system.time(fatcat <- do.call(rbind, pbmcapply::pbmclapply((1:length(CATHUNP2[,1])), getFATCAT2, mc.cores = NUM_CORES))) 
  write.table(fatcat, file = file.path(data, "data09_FATCAT_RMSD.tab"), row.names = F,      col.names = T, quote = F, sep = "\t")
}

```
