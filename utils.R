
pkg_required <- c("dplyr", "httr", "bio3d", "msa", "lubridate", "parallel", 
                  "stringr", "ggplot2", "reshape2")

supress_message <- function(x){suppressPackageStartupMessages(require(x, character.only = TRUE))}
sapply(pkg_required, supress_message)



#'ResRange2ResVector
#'@description converts the character format of residue range to residue vector.
#'Multiple residue range could be separated by coma.
#'example, "1-150" OR "9-204, 368-428"   OR "9-204,368-428, 440-500"

ResRange2ResVector <- function(ResRange = NULL){
  residue_vector<- c()
  dom_section <- strsplit( ResRange, split=",")[[1]]
  for (ds in seq_along(dom_section)){
    seg_beg <- strsplit(dom_section[ds], split="-")[[1]][1] %>% as.numeric(.)
    seg_end <- strsplit(dom_section[ds], split="-")[[1]][2] %>% as.numeric(.)
    residue_vector <- c(residue_vector, seg_beg:seg_end)
  }
  return(residue_vector)
}



#'Vector2HyphenSeg
#' In protein 3D structures small loops are often missing. Therefore 
#' a continuous vector representing the residue num vector is sometime 
#' misleading.
#' 
#' @param resno <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 17, 18, 19, 20)
#' @return character, hyphenated segments separated by coma 
#' @example Vector2HyphenSeg(resno) 
#' @result [1] "1-10,15-20"

#vector to hyphenated segment 
Vector2HyphenSeg <- function(NumericVector = NULL){
  
  if(!is.numeric(NumericVector)) stop("Numeric vector expected\n")
  zmin <- min(NumericVector)
  zmax <- max(NumericVector)
  
  #continuous seq
  seq_cont <- seq(zmin, zmax)
  z_continuous_logical <-  seq_cont %in% NumericVector
  seq_cont[!z_continuous_logical] <- "|"
  
  seq2 <- paste0(seq_cont, collapse = ",") %>% strsplit(., split="\\|") %>% .[[1]]
  
  seq3 <- seq2[seq2 != ","]
  
  #hyphenated_seg
  hs <- list()
  
  for(seg_no in seq_along(seq3)){
    #seg_no <- 1
    # segments
    seg <- strsplit(seq3[seg_no], ",")[[1]] %>% as.numeric(.) %>% .[!is.na(.)]
    
    hs[seg_no] <- paste0(min(seg), "-", max(seg))
    
  }
  
  hs_final <- unlist(hs) %>% paste0(., collapse = ",")
  
  return(hs_final)
}


#'HyphenSeg2Vec
#' Converts hypenated vector segment generated by "Vector2HyphenSeg" to vector again.
#'
#' @param HyphenSeg A character of the form "1-4" Or "1-4,8-14"
#'  
#' @example HyphenSeg2Vec("1-4") 
#' @returns  [1] 1 2 3 4
#' 
#' @example HyphenSeg2Vec("1-4,8-14") 
#' @returns  [1] 1 2 3 4 8 9 10 11 12 13 14
#'
HyphenSeg2Vec <- function(HyphenSeg = NULL){
  vec <- c()
  for(hs in strsplit(HyphenSeg, split=",")[[1]]){
    if(length(strsplit(hs, split="-")[[1]])  !=2) stop("Type of input is not expected\n")
    
    hsmin <- as.numeric(strsplit(hs, split="-")[[1]][1])
    if(is.na(hsmin)) stop("Type of input is not expected1\n")
    
    hsmax <- as.numeric(strsplit(hs, split="-")[[1]][2])
    if(is.na(hsmax)) stop("Type of input is not expected2\n")
    
    vec  <- append(vec, seq(hsmin, hsmax))
  }
  return(vec)
}



#############################################################################..#
#' CATH database related functions
#require(httr)
#Cath_db_version
GetCthDomStr <- function(CthLocalDb = NULL , 
                         Cath_db_version = NULL, 
                         Cath_domain = NULL, 
                         verbose = F) {
  
  if(verbose){
    message("
The function can download the structure data for all 
version of CATH db, following versions can be downloaded
using the function:
v2_0
v2_4
v2_5
v2_5_1
v2_5_3
v2_6_0
v3_0_0
v3_1_0
v3_3_0
v3_4_0
v3_5_0
v4_0_0
v4_1_0
v4_2_0
v4_3_0
By default CATH structure data is saved in 
data/CATHdb\n")
  }
  if (is.null(Cath_db_version)) Cath_db_version <- "v4_3_0"
  #Cath_domain <- "1a0iA02"
  Cath_domain_str <- paste0(Cath_domain, ".pdb")
  
  CthSite4AtmRec_base <- paste0("https://www.cathdb.info/version/", 
                                Cath_db_version, "/api/rest/id/")
  
  if(!dir.exists(file.path(CthLocalDb, Cath_db_version)))  {
    dir.create(file.path(CthLocalDb, Cath_db_version))
  } else {
    if(verbose){
      message(cat(sprintf("
The directory for the db version -- %s -- aleardy exists at\n
%s, 
downloading in the existing dir\n", 
                          Cath_db_version, file.path(CthLocalDb, Cath_db_version))))
    }
  }
  
  if (!file.exists(file.path(CthLocalDb, Cath_db_version, Cath_domain_str))){
    CthSite4AtmRec <- paste0(CthSite4AtmRec_base, Cath_domain_str)
    r  <- GET(CthSite4AtmRec)
    bin <- content(r, "raw")
    writeBin(bin, file.path(CthLocalDb, Cath_db_version, Cath_domain_str))
  } else {
    if(verbose){
      message(cat(sprintf("
The file -- %s -- aleardy exists, skipping the download\n", 
                          file.path(CthLocalDb, Cath_db_version, Cath_domain_str))))
    }
  }
  
  
}
#cdv <- "v4_3_0"
#GetCthDomStr(local_db_location, cdv, "11baA00", verbose = T)





#====================== CATHdb str download ENDS ===============================

#############################################################################..#
#' Alphafold related functions
#'
# To download single structure prgramatically following link can be used 
# the second field in the name is uniprot id
# af2website <- "https://alphafold.ebi.ac.uk/files/AF-F4HVG8-F1-model_v3.pdb"


# unpid <- "P00735"

GetAF2str <-  function(unpid = NULL, af2dbpath=NULL, verbose = T){
  af2_id <- paste0(unpid, "-F1-model_v3.pdb")
  
  af2site <- paste0("https://alphafold.ebi.ac.uk/files/AF-", af2_id)
  OutFile <- file.path(af2dbpath, af2_id)
  if (!file.exists(OutFile)){
    r  <- httr::GET(af2site)
    bin <- content(r, "raw")
    writeBin(bin, OutFile)
    return(c(af2_id, r$status_code))
  } else {
    if (verbose) cat(sprintf(
      " The file -- %s -- is aready downloaded moving to next one\n", unpid))
    return(c(af2_id, "File exists"))
  }
}
##############################################################################.#


##########################  RCSB DOWNLOAD  ###################################.#
#Download  coordinate file from RCSB

GetRCSBcoordFile <- function(pdbid=NULL, FileType=NULL, Compress=T, output_path = NULL){
  
  if (FileType == "pdb" & isTRUE(Compress)){
    pdbresturl <- paste0("https://files.rcsb.org/download/", pdbid, ".pdb", ".gz")
    outputFN <- paste0(pdbid, ".pdb", ".gz")
  } else if (FileType == "pdb" & isFALSE(Compress)){
    pdbresturl <- paste0("https://files.rcsb.org/download/", pdbid, ".pdb")
    outputFN <- paste0(pdbid, ".pdb")
  } else if (FileType == "cif" & isTRUE(Compress)){
    pdbresturl <- paste0("https://files.rcsb.org/download/", pdbid, ".cif", ".gz")
    outputFN <- paste0(pdbid, ".cif", ".gz")
  } else if (FileType == "cif" & isFALSE(Compress)){
    pdbresturl <- paste0("https://files.rcsb.org/download/", pdbid, ".cif")
    outputFN <- paste0(pdbid, ".cif")
  }
  
  r  <- httr::GET(pdbresturl)
  if(r$status_code == 200){
    bin <- suppressMessages(httr::content(r, "raw"))
    if (is.null(output_path)){
      writeBin(bin, outputFN)
    }else {
      writeBin(bin, file.path(output_path, outputFN))
    }
    
  }else {
    message(paste0("
    Warning: Download unsccessful 
    RCSB responded with status code ", r$status_code))
  }
  return(r$status_code)
}
##############################################################################.#

########################## STRIDE WRAPPER FUNCTION ###########################.#
#' Calculate secondary structure element, absolute and relative solvent accessible 
#' surface area (SASA), and buried surface area of protein.
#' @param pdb file name/ File name with path


# standard amino acid area. Data obtained from NACCESS
sa <- read.table(file.path(data,"standard.data", skip = 1))
#STANDARD ACCESSIBILITES FOR PROBE 1.40 AND RADII vdw.radii
# REM RES _ NUM      All-atoms   Total-Side   Main-Chain    Non-polar    All polar
# REM                ABS   REL    ABS   REL    ABS   REL    ABS   REL    ABS   REL
# ATOM  S  2 ALA 107.95  0  69.41  0   0.00   0  69.41   0 38.54   0  71.38   0  36.58   0
# ATOM  S  2 CYS 134.28  0  96.75  0   0.00   0  96.75   0 37.53   0  97.93   0  36.35   0
# ATOM  S  2 ASP 140.39  0  48.00  0  54.69   0 102.69   0 37.70   0  49.24   0  91.15   0
Std_Area_Mapping <- function(ResID){
  if(any(sa$V4 %in% ResID)) {
    sa_data <- sa$V5[which(sa$V4 %in% ResID)]
    
  } else sa_data <-  NA
  return(sa_data)
}

#'@aliases stride.WF
#'@description
#'Stride wrapper function prepares atom wise tabulated data obtained from STRIDE
#'with additional coloum of relative Surface accessible 
#'
stride.WF <- function(pdbFN, STRIDE_PATH=STRIDE_PATH){
  # cth domain stride filename
  strideFN <- tempfile(pattern = "CATH_", fileext = '.STRIDE', tmpdir = "~/temp")
  #system("~/Applications/STRIDE/stride --help")
  # stride_output
  stride_status <- system(paste0(STRIDE_PATH, " ", pdbFN, "> ", strideFN), ignore.stderr = T, wait =T, ignore.stdout = F, intern = F)
  sse_raw <- grep(readLines(strideFN), pattern = "^ASG", value = T)
  
  if (length(sse_raw)!=0){
    
    if(file.exists(strideFN)){
      invisible(file.remove(strideFN))
    }

    extract_SSE <- function(Line){
      
      #line split
      LS <- strsplit(Line, split=" ")[[1]] %>% .[.!=""]
      
      if(length(LS) == 11){
        LS2 <- LS[-c(1, length(LS))]
      }else LS2 <- rep(NA, 9)
      
      return(LS2)
    }
    #strsplit(sse_raw[1], split=" ")[[1]] %>% .[.!=""] %>% .[-c(1, length(.))]
    sse.list <- do.call(rbind, lapply(sse_raw, extract_SSE))
    sse <- as.data.frame(sse.list)
    
    names(sse) <- c("Resid", "Chain", "Resno", "SNo", "SSE_short", "SSE_long", "Phi", "Psi", "Area")
    #names(sse) <- c("Resid", "Chain", "Resno", d, "SSE_short", "SSE_long", "Phi", "Psi", "Area")
    sse$Std_Area <- rep(NA, length(dim(sse)[1]))
    sse$Std_Area <- lapply(sse$Resid, Std_Area_Mapping) %>% unlist
    sse <- sse[complete.cases(sse),]
    sse$RelASA <- with(sse, (as.numeric(Area)*100)/Std_Area) %>% round(., 2)
    sse$RelASA[sse$RelASA > 100] <- 100
    sse$RelASA[sse$RelASA < 0] <- 0
    
    sse$RelBSA <- with(sse, 100 - RelASA) %>% round(., 2)
    
    return(sse)
  } else return(sse = NULL)
}

#stride.WF(pdbFN = "/xx/xx/xx/xx/xx/v4_3_0/4bswB01.pdb")
##############################################################################.#






### ---------------------------------------- -
### DDM ------------------------------------ -
v2m <- function(x){ matrix(x, nrow = 3, byrow = FALSE) }
DM <- function(x, log=FALSE){
  ## Given one conformation where each column is the xyz of 1 atom,
  n <- dim(x)[2]
  d <- array(NA, dim=c(n,n))
  for (i in 1:n){
    for (j in i:n){
      d[i,j] <- d[j,i] <- sqrt( sum( (x[,i] - x[,j])^2 ) )
    }
  }
  
  if(log){
    diag(d) <- 1
    d <- log2(d)
  }
  
  if (all(is.null(rownames(d)))){ rownames(d) <- sprintf('r%d',1:n); }
  if (all(is.null(colnames(d)))){ colnames(d) <- sprintf('c%d',1:n); }
  
  return(d)
}
DDM <- function(x1, x2){
  DM(x1) - DM(x2)
}
rbhDM <- function( d, mid=10, high = 'white', low = 'black' ){
  r <- rbh( d, legend_title = expression(paste( '(r'[i], ' - r'[j], ')'^2 )),
            grid_line_color = FALSE, high = high, low = low, mid = mid, return_object = TRUE)
  r <- r + theme( axis.text.x = element_blank(), axis.text.y = element_blank(),
                  panel.background = element_rect(fill='white', colour='black')) +
    xlab( expression('r'[i]) ) + ylab( expression('r'[j]) ) +
    coord_fixed( ratio = 1 )
  return(r)
}



#' Wrapper function to plot 
#' @param dr
#' @param avg_3x3 [TRUE] This option will average 3x3 regions to reduce the size of plotted objects
#' @param reference_level ['WT'] When comparing the distribution of values, compare each level to this revernece level(s)
plot.DDM <- function(dr = dr, avg_3x3 = TRUE, reference_level = 'WT', domains = NULL, domain.color = rep(c('gray90','lightblue1'), length.out=length(domains) )){
  
  # Get the global range
  col_range <- sapply(dr, c) %>% range
  col_range <- c( ceiling(col_range[1]), floor(col_range[2]) )
  
  # Plot the DDM matrices as heatmaps
  tmp <- sapply( dr, function(x){
    
    if (avg_3x3){
      # Average 3x3 grid to reduce size (the PDFs were many Gb in size)
      i_max <- floor(dim(x)[1]/3)
      d9 <- array(0, dim=c(i_max,i_max))
      for (i in 1:(i_max)){
        for(j in 1:(i_max)){
          d9[i,j] <- median(x[ (3*i-2):(3*i), (3*j-2):(3*j)], na.rm=TRUE)
        }
      }
      rownames(d9) <- rownames(x)[3*( 1:(i_max)) - 2]
      colnames(d9) <- colnames(x)[3*( 1:(i_max)) - 2]
    } else {
      d9 <- x
    }
    
    # make main plot
    dat <- reshape2::melt( d9, as.is=TRUE )
    dat$Var1 <- factor( dat$Var1, levels = rownames(d9) )
    dat$Var2 <- factor( dat$Var2, levels = colnames(d9) )
    g <- ggplot( dat, aes(Var2,Var1)) +
      geom_tile( aes_string(fill = 'value' ), colour=NA ) +
      scale_fill_gradient2(midpoint=0, low="#2166AC", high="#B2182B", name = 'Distance', limits = col_range ) +
      labs(title = '') + xlab(expression('Residue'[i])) + ylab(expression('Residue'[j])) +
      scale_x_discrete(expand = c(0, 0)) + coord_fixed()
    
    # add sidebar for protein domain
    if (all(!is.na(domains))){
      if (avg_3x3){ domains <- lapply(domains, function(x){ floor(x/3) }) } # make into 1/3rd
      g <- g + annotate("rect", xmin = dim(d9)[1]*1.01, xmax = dim(d9)[1]*1.05,
                        ymin = sapply(domains,min), ymax = sapply(domains,max), alpha = .2,
                        col  = domain.color,
                        fill = domain.color
      )
      g <- g + annotate("text", x=dim(d9)[1]*1.03, y=sapply(domains,mean), label=names(domains), angle = -90)
    }
    
    # show the plot
    print(g)
    
    # return
    return(d9)
    
  })
  
  # Plot a summary across all DDMs
  # Show the distribution of values
  if ( all(reference_level %in% names(dr)) ){
    
    i <- names(dr) %in% reference_level
    ref_den <- density( unlist(dr[i]) %>% c() )
    
    other_levels <- setdiff( names(dr), reference_level )
    for (lvl in other_levels){
      i <- names(dr) %in% lvl
      lvl_den <- density( unlist(dr[i]) %>% c())
      plot( ref_den, main=lvl, ylim=range(c( ref_den$y, lvl_den$y )) )
      lines(lvl_den, col='orange')
      abline(v=0, col = "gray65")
      legend('topright', lty=1, col=c('black','orange'),
             legend=c( paste(reference_level, sep=',', collapse=','), lvl ))
    }
    
  } else {
    warnings('Input did not have requested refernece levels in input dataset names. Skipping distribution comparisons.')
  }
  
  # return
  return(invisible(NULL))
  
}

#'
summary.DDM <- function(x){
  cat(sprintf('DDM list object with %d elements\n', length(x)))
  tmp <- sapply(x, function(y){ c(median(y, na.rm=TRUE),
                                  mad(   y, na.rm=TRUE),
                                  mean(  y, na.rm=TRUE),
                                  sd(    y, na.rm=TRUE)  )}) %>% t()
  colnames(tmp) <- c('Median', 'MAD', 'Mean', 'SD')
  return(tmp)
}



#'@description
#'Local distance difference test.
#'@Input Takes two arguments First, Ca dist diff matrix from two strs, one-to-one mapped.
#'Second, a vector of cutoff at which dist diff is to be tabulated.
#'@output The function extracts tabular data of distance difference from the distance 
#'difference matrix
#'
LDDTca <- function(x=DifferenceMatrix, c=CutOffVector){
  if(is.matrix(x)){
    n <- dim(x)[1]
  } else {stop("The x data should be a matrix\n")}
  
  lddtca <- c()
  lddtca_name <- c()
  idx <- 0
  for(i in c){
    idx <- idx+1
    #print(i)
    
    #distance difference for cut off
    dd1 <- x[which(x >= i)]   
    
    if(length(dd1) != 0){
      #Average dist diff for cutoff
      lddtca[idx] <- sum(dd1)/length(dd1)
      lddtca_name[idx] <- paste0("DD4TH_", i)
    } else { 
      lddtca[idx] <- 0
      lddtca_name[idx] <- paste0("DD4TH_", i)
    }
    
    
    idx <- idx+1
    #fraction of residues above cut off
    #lddtca[idx] <- (sum(x>=i) * 100)/(n^2)
    
    ## square root will give a sense of num of residues and division by total num of residue 
    ## gives appropriate sense of fraction of residues under this category.
    lddtca[idx] <- sqrt(sum(x>=i))  / n 
    lddtca_name[idx] <- paste0("FracAbove_", i)
    
  }
  names(lddtca) <- lddtca_name
  return(lddtca)
}



#'@description
#'Local distance difference test. version 2
#'@Input Takes two arguments First, Ca dist diff matrix from two strs, one-to-one mapped.
#'Second, a vector of cutoff at which dist diff is to be tabulated.
#'@output The function extracts tabular data of distance difference from the distance 
#'difference matrix
#'
LDDTca2 <- function(x=DifferenceMatrix, c=CutOffVector){
  # x <- ddmp %>% abs()
  # c <- c(0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5)
  
  if(is.matrix(x)){
    n <- dim(x)[1]
  } else {stop("The x data should be a matrix\n")}
  
  lddtca <- c()
  lddtca_name <- c()
  idx <- 0
  for(i in c){
    idx <- idx+1
    
    Av_DD_res <- c()
    for(k in 1:n){
      
      # Dist Diff average of a residue
      if(k != n){DD_res <- x[k,][(k+1):(n-k)]} else{DD_res <- x[k,][1:(n-1)]}
      
     Av_DD_res <-  c(Av_DD_res, DD_res[DD_res > i] %>% mean())
     Av_DD_res[is.nan(Av_DD_res)] <- 0
    }
    
    # Average over all residues of the structure
    DD_AV_over_all_res <- Av_DD_res %>% mean()
    
    
    lddtca[idx] <- DD_AV_over_all_res
    lddtca_name[idx] <- paste0("DD4TH_", i)

    # if(length(dd1) != 0){
    #   #Average dist diff for cutoff
    #   lddtca[idx] <- DD_AV_over_all_res
    #   lddtca_name[idx] <- paste0("DD4TH_", i)
    # } else { 
    #   lddtca[idx] <- 0
    #   lddtca_name[idx] <- paste0("DD4TH_", i)
    # }
    
    
    idx <- idx+1

    
    lddtca[idx] <-  (length(Av_DD_res[Av_DD_res !=  0]))  / n
    lddtca_name[idx] <- paste0("FracAbove_", i)
    
  }
  names(lddtca) <- lddtca_name
  return(lddtca)
}


#'@description
#'Creating a wrapper function for a Gene Ontology (GO) annotation API call.
#
isJobReady <- function(jobId) {
  pollingInterval = 5
  nTries = 20
  for (i in 1:nTries) {
    url <- paste("https://rest.uniprot.org/idmapping/status/", jobId, sep = "")
    r <- GET(url = url, accept_json())
    status <- content(r, as = "parsed")
    if (!is.null(status[["results"]]) || !is.null(status[["failedIds"]])) {
      return(TRUE)
    }
    if (!is.null(status[["messages"]])) {
      print(status[["messages"]])
      return (FALSE)
    }
    Sys.sleep(pollingInterval)
  }
  return(FALSE)
}


#'@description
#'Creating a wrapper function for URL edit
#' In the context of Gene Ontology (GO) annotation API call.
#
getResultsURL <- function(redirectURL) {
  if (grepl("/idmapping/results/", redirectURL, fixed = TRUE)) {
    url <- gsub("/idmapping/results/", "/idmapping/stream/", redirectURL)
  } else {
    url <- gsub("/results/", "/results/stream/", redirectURL)
  }
}



############################# Align and Visualizarion two structures

overLay2PDBs <- function(pdbfile1=NULL, pdbfile2=NULL){
  if(dir.exists("~/temp/")){
    for(i in list.files("~/temp/", full.names = T)){
      if(file.exists(i)){
        invisible(file.remove(i))
      }
    }
  }
  
  dom1 <- pdbfile1
  dom2 <- pdbfile2
  
  p1 <- read.pdb(dom1)
  p2 <- read.pdb(dom2)
  
  
  p1.ind <- atom.select(p1, resno=unique(p1$atom$resno), elety='CA')
  p2.ind <- atom.select(p2, resno=unique(p2$atom$resno), elety='CA')
  
  xyz <- fit.xyz(fixed=p1$xyz, mobile=p2$xyz,
                 fixed.inds=p1.ind$xyz,
                 mobile.inds=p2.ind$xyz)
  
  # Write out moved PDB
  C <- p2; C$xyz = xyz
  p2_moved_FN <- tempfile(pattern = "file", fileext = ".pdb", tmpdir = "~/temp/")
  #p2_moved_FN <- "TEMP1.pdb"
  
  write.pdb(pdb=C, file = p2_moved_FN)
  
  p2m <- read.pdb(p2_moved_FN)
  
  p3 <- cat.pdb(p1, p2m)
  
  p3cat_FN <- tempfile(pattern = "file", fileext = ".pdb", tmpdir = "~/temp/")
  #p3cat_FN <- "TEMP.pdb"
  write.pdb(pdb=p3, file = p3cat_FN)
  
  
  NGLVieweR( p3cat_FN ) %>% addRepresentation("cartoon") %>% stageParameters(backgroundColor = "teal", zoomSpeed = 1)
  
}




##################################### Compare two structures
CathAf2Comparision   <- function(cthdom=NULL, DomDir_cth=NULL, DomDir_af2=NULL, chunksize=60){
  f1 <- file.path(DomDir_cth, paste0(cthdom, ".pdb")) # cath domain pdb
  f2 <- file.path(DomDir_af2, paste0(cthdom, "_af2.pdb"))

  f1p <- read.pdb(f1)
  f1s <- f1p$atom[f1p$calpha,]$resid %>% aa321() %>% paste0(., collapse = '')
  f2p <- read.pdb(f2)
  f2s <- f2p$atom[f2p$calpha,]$resid %>% aa321() %>% paste0(., collapse = '')
  pa <- pairwiseAlignment(f2s, f1s)
  
  message('Percent identity in Alignment')
  cat(sprintf("%s\n",pid(pa)))
  
  printPairwiseAlignment(pa, chunksize = chunksize)
}